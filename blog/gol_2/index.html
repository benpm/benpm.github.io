<!doctype html><html lang=en-us>
<head>
<title>Multi-State Cellular Automata in WebGL | benpm.github.io</title>
<meta charset=utf-8>
<meta name=language content="en">
<meta name=description content="How to compactly store multi-state cellular automata rules into a texture">
<meta name=keywords content="game of life ,cellular automata ,webgl ,glsl ,shader ,fragment ,simulation">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Multi-State Cellular Automata in WebGL">
<meta name=twitter:description content="How to compactly store multi-state cellular automata rules into a texture">
<meta name=twitter:site content="https://twitter.com/_bpmw">
<meta name=twitter:creator content="https://twitter.com/_bpmw">
<link rel="shortcut icon" type=image/png href=/favicon.ico>
<link type=text/css rel=stylesheet href=/css/post.min.9a955b519df490cf1c93b17141356c3fab7466ff91d74f7b8ac70697c3635fa2.css integrity="sha256-mpVbUZ30kM8ck7FxQTVsP6t0Zv+R1097iscGl8NjX6I=">
<link type=text/css rel=stylesheet href=/css/custom.min.07e9b415621806a47b49ec8c7ecdbf25587cfa93cfee5f5019087c00a2e528c1.css integrity="sha256-B+m0FWIYBqR7SeyMfs2/JVh8+pPP7l9QGQh8AKLlKME=">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/benpm.github.io\/"},"articleSection":"blog","name":"Multi-State Cellular Automata in WebGL","headline":"Multi-State Cellular Automata in WebGL","description":"How to compactly store multi-state cellular automata rules into a texture","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2022","datePublished":"2022-09-15 13:00:19 -0700 -0700","dateModified":"2022-09-15 13:00:19 -0700 -0700","url":"https:\/\/benpm.github.io\/blog\/gol_2\/","wordCount":"2156","keywords":["game of life","cellular automata","webgl","glsl","shader","fragment","simulation","Blog"]}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PPST2B8G8Z"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PPST2B8G8Z')</script></head>
<body>
<div class=burger__container>
<div class=burger aria-controls=navigation aria-label=Menu>
<div class="burger__meat burger__meat--1"></div>
<div class="burger__meat burger__meat--2"></div>
<div class="burger__meat burger__meat--3"></div>
</div>
</div>
<nav class=nav id=navigation>
<ul class=nav__list>
<li>
<a href=/>splash!</a>
<div class=indicator></div>
</li>
<li>
<a class=active href=/blog>blog</a>
<div class="indicator active"></div>
</li>
<li>
<a href=/experiments>experiments</a>
<div class=indicator></div>
</li>
<li>
<a href=/gamedev>gamedev</a>
<div class=indicator></div>
</li>
<li>
<a href=/music>music</a>
<div class=indicator></div>
</li>
<li>
<a href=/projects>projects</a>
<div class=indicator></div>
</li>
<li>
<a href=https://github.com/benpm/cv/raw/master/benpm_cv.pdf>cv (download)</a>
<div class=indicator></div>
</li>
</ul>
</nav>
<main>
<div class=flex-wrapper>
<div class=post__container>
<div class=post>
<header class=post__header>
<h1 id=post__title>Multi-State Cellular Automata in WebGL</h1>
<time datetime="2022-09-15 13:00:19 -0700 -0700" class=post-date>Sep 2022</time>
</header>
<article class=post__content>
<p><em>This is a rewrite and significant expansion of my first cellular automata article. It covers everything in the first article, plus a significant amount of explanation of multi-state automata. If you&rsquo;re coming from the first article, feel free <a href=#encoding-multiple-states>skip to that part</a>.</em></p>
<p>I&rsquo;ve always been fascinated with cellular automata like Conway&rsquo;s Game of Life. The idea that complex and interesting behavior can emerge from simple rules is captivating to me. In this document I&rsquo;ll explain my method of encoding a class cellular automata rules, as well as how I implemented my simulator.</p>
<p><img src=/images/cellular_automata/banner.gif alt></p>
<h2 id=the-basics>The Basics<a class=anchor href=#the-basics>#</a></h2>
<p>Cellular automata are essentially an arrangement of cells with states (in our case, integers) that are determined by a <strong>rule</strong>. These rules are functions which take the states of a cell and its neighbors as input, and produce the cell&rsquo;s new state as output. By applying this rule to every cell simultaneously, we advance the simulation in time.</p>
<p>For this undertaking we will only consider <strong>totalistic</strong> cellular automata with a <strong>Moore neighborhood</strong>, which contains the eight immediately adjacent cells. By being totalistic, these rules only take into account the <em>total</em> number of cells of each state in the neighborhood, ignoring their arrangement.</p>
<p><img class="invertable drawing" src=/images/cellular_automata/illustration_1.png alt="With totalistic automata, the arrangement of neighboring cells is ignored. Here, there are three possible states, labeled 0 through 2."></p>
<p>With these definitions we can specify a <strong>rule function</strong>, $F$:</p>
<p>$$ o = F(c, N) $$</p>
<p>$o$ is the output state, $c$ is the current state, and $N$ is a sequence of integers which represents the total neighbor count for each possible state: the $i^{th}$ element of $N$ is the total number of neighbors with state $i$. In the above example, $c=0$ and $N=(3,3,2)$.</p>
<p>To begin, let&rsquo;s just consider two possible states: &ldquo;on&rdquo; ($1$) and &ldquo;off&rdquo; ($0$), like in Game of Life. The first thing to notice is that since the total number of neighbors is always 8, we only need to consider the number of ($1$) neighbors, as the number of ($0$) neighbors is always $8 - N_1$. (We could also choose to only count the number of ($0$) neighbors).</p>
<p>So how do we represent the rule function so that we can simulate <em>any</em> two-state rule under our constraints? Well, since the inputs to our functions are just integers, we can use them to index a table, like this one:</p>
<table>
<thead>
<tr>
<th>$c$ / $N_1$</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>(0)</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>(1)</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>0</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
</tbody>
</table>
<p>Here, we have a table that contains output states, which we find by querying the table by row (current state, $c$) and column (number of ($1$) neighbors, $N_1$). In the above example, $F(1,5)=0$, so if a cell&rsquo;s state is ($1$), and it has five ($1$) neighbors, it becomes ($0$).</p>
<p>Let&rsquo;s try to encode Game of Life in this format. The rules of Game of Life, in English, are:</p>
<ol>
<li>Any <em>on</em> cell with two or three <em>on</em> neighbours stays <em>on</em></li>
<li>Any <em>off</em> cell with three <em>on</em> neighbours turns <em>on</em></li>
<li>All other cells turn <em>off</em>, including cells that are already <em>off</em></li>
</ol>
<p>So, in our table representation of $F$:</p>
<table>
<thead>
<tr>
<th>$c$ / $N_1$</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>(0)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>(1)</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Nice and simple! Now we can start thinking about how to use this in a shader. The simulation will take place on an integer-format texture, which we can access like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#09f;font-style:italic>// simulate.frag</span>
<span style=color:#099>#version 300 es</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uSim; <span style=color:#09f;font-style:italic>// Simulation texture</span>
<span style=color:#069;font-weight:700>in</span> <span style=color:#069;font-weight:700>vec2</span> vTextureCoord;         <span style=color:#09f;font-style:italic>// Texture coordinates 0.0 to 1.0</span>

<span style=color:#069;font-weight:700>void</span> main(<span style=color:#069;font-weight:700>void</span>) {
    <span style=color:#09f;font-style:italic>// Get the current state</span>
    <span style=color:#069;font-weight:700>int</span> curstate <span style=color:#555>=</span> <span style=color:#069;font-weight:700>int</span>(texture(uSim, vTextureCoord).r);

    <span style=color:#09f;font-style:italic>// Determine number of (1) neighbors</span>
    <span style=color:#069;font-weight:700>int</span> count <span style=color:#555>=</span> <span style=color:#555>-</span>curstate;
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> x <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; x <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; x <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> y <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; y <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; y <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
            <span style=color:#069;font-weight:700>if</span> (v <span style=color:#555>==</span> <span style=color:#f60>1</span>) {
                count <span style=color:#555>+=</span> <span style=color:#f60>1</span>;
            }
        }
    }
}
</code></pre></div><blockquote>
<p><strong>NOTE:</strong> We initialize <code>count</code> to <code>-curstate</code> to prevent counting the current cell. It also avoids branching, which can be expensive on a GPU, <a href=https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-34-gpu-flow-control-idioms target=_blank rel="noreferrer noopener">depending on the situation</a>.</p>
</blockquote>
<p>Now that we have $c$ as <code>curstate</code> and $N_1$ as <code>count</code>, we can grab our next state from the rule, which is also stored in a texture:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#09f;font-style:italic>// simulate.frag</span>
<span style=color:#099>#version 300 es</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uRule; <span style=color:#09f;font-style:italic>// Rule table</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uSim;  <span style=color:#09f;font-style:italic>// Simulation texture</span>
<span style=color:#069;font-weight:700>in</span> <span style=color:#069;font-weight:700>vec2</span> vTextureCoord;          <span style=color:#09f;font-style:italic>// Texture coordinates 0.0 to 1.0</span>
<span style=color:#069;font-weight:700>out</span> uvec3 fragColor;

<span style=color:#069;font-weight:700>void</span> main(<span style=color:#069;font-weight:700>void</span>) {
    <span style=color:#09f;font-style:italic>// Get the current state</span>
    <span style=color:#069;font-weight:700>int</span> curstate <span style=color:#555>=</span> <span style=color:#069;font-weight:700>int</span>(texture(uSim, vTextureCoord).r);

    <span style=color:#09f;font-style:italic>// Determine number of (1) neighbors</span>
    <span style=color:#069;font-weight:700>int</span> count <span style=color:#555>=</span> <span style=color:#555>-</span>curstate;
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> x <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; x <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; x <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> y <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; y <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; y <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
            <span style=color:#069;font-weight:700>if</span> (v <span style=color:#555>==</span> <span style=color:#f60>1</span>) {
                count <span style=color:#555>+=</span> <span style=color:#f60>1</span>;
            }
        }
    }

    uint newstate <span style=color:#555>=</span> texelFetch(uRule, <span style=color:#069;font-weight:700>ivec2</span>(count, curstate), <span style=color:#f60>0</span>).r;
    fragColor <span style=color:#555>=</span> uvec3(newstate);
}
</code></pre></div><blockquote>
<p><strong>NOTE:</strong> Here we use <a href=https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/texelFetch.xhtml target=_blank rel="noreferrer noopener"><code>texelFetch()</code></a> instead of <a href=https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/texture.xhtml target=_blank rel="noreferrer noopener"><code>texture()</code></a> to avoid expensive floating-point conversion and fragment-to-texel coordinate conversion. We don&rsquo;t do this for sampling the simulation texture because it doesn&rsquo;t support texture wrapping.</p>
</blockquote>
<p>To run our simulation, we use two different textures attached to framebuffers, one as output, one as input. By alternating their roles each time step, our desired result is finally produced!</p>
<p>So how many possible rules does this give us? Well, there are 2 possible values for $c$, and 9 possible values for $N_1$ (that&rsquo;s 0, 1, 2&mldr; up to and including 8). Since $F$ can only return 2 possible values, the total number of possible rules is $2^{2\cdot9} = 262144$! Not bad, but we can do better&mldr;</p>
<h2 id=encoding-multiple-states>Encoding Multiple States<a class=anchor href=#encoding-multiple-states>#</a></h2>
<p><img src=/images/cellular_automata/banner2.gif alt></p>
<p>Although two states is enough to produce interesting behavior, multi-state rules can have <a href=https://en.wikipedia.org/wiki/Brian%27s_Brain target=_blank rel="noreferrer noopener">some</a> <a href=https://en.wikipedia.org/wiki/Wireworld target=_blank rel="noreferrer noopener">very</a> <a href=https://en.wikipedia.org/wiki/Codd%27s_cellular_automaton target=_blank rel="noreferrer noopener">cool</a> <a href=https://en.wikipedia.org/wiki/Von_Neumann_cellular_automaton target=_blank rel="noreferrer noopener">properties</a>, so let&rsquo;s figure out how to encode these more complex rules efficiently.</p>
<p>First let&rsquo;s just imagine the case were we have 3 states instead of 2. Not only do we need an additional neighbor count $N_2$ as input to our rule function, but the set of possible inputs becomes more nuanced. For example, if $N_2 = 4$, the possible neighbor counts for ($1$) and ($0$) are restricted, because the sum of all neighbor counts must equal 8. In other words:</p>
<p>$$
\sum^{n-1}_{i=0} N_i = 8
$$</p>
<p>In this case, $N=(3,4,5)$ is <em>invalid</em> because the sum of $N$ would unfortunately be 12, not 8. Of course, this applied our 2-state case as well, but we didn&rsquo;t have to worry about it because the value of $N_0$ was implicitly defined solely by $N_1$.</p>
<p>So how do we index our rule texture with this property in mind? Well, let&rsquo;s start by looking at how we might want to map possible $N$s to indices, by sort of &ldquo;counting up&rdquo;:</p>
<table>
<thead>
<tr>
<th>input states ($N_0$,$N_1$,$N_2$)</th>
<th>index</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(0,0,8)</code></td>
<td>0</td>
</tr>
<tr>
<td><code>(0,1,7)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>(0,2,6)</code></td>
<td>2</td>
</tr>
<tr>
<td>&mldr;</td>
<td></td>
</tr>
<tr>
<td><code>(0,7,1)</code></td>
<td>7</td>
</tr>
<tr>
<td><code>(0,8,0)</code></td>
<td>8</td>
</tr>
<tr>
<td><code>(1,0,7)</code></td>
<td>9</td>
</tr>
<tr>
<td>&mldr;</td>
<td></td>
</tr>
<tr>
<td><code>(1,6,1)</code></td>
<td>15</td>
</tr>
<tr>
<td><code>(1,7,0)</code></td>
<td>16</td>
</tr>
<tr>
<td><code>(2,0,6)</code></td>
<td>17</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>NOTE:</strong> We are just considering $N$ here because adding in $c$ is simple: we just multiply the index of $N$ by $c$ to get the final index into the rule texture.</p>
</blockquote>
<p>The first thing to notice is that the first 9 entries have $N_0=0$, which is like we only have two states. This means that if we allowed for a 4th state, we could just add on to the end of the table. It also means we can express the length of the table (the total number of possible $N$s) as a function of the number of states, $n$.</p>
<p>One state has 1 possible inputs, two states has 9, and if we extended the table we&rsquo;d find that 3 states gives us 45 possible inputs. The <a href=https://oeis.org target=_blank rel="noreferrer noopener">OEIS</a> tells us that the sequence of 1, 9, 45, &mldr; is $\binom{n+7}{8}$. Notice: 8 is our target sum and 7 is just 8-1. Indeed, $\binom{n+s-1}{s}$ is the general form for any target sum $s$.</p>
<p>So where do these numbers come from? Well, if we arrange the possible input sequences by state, it becomes clear:</p>
<p><img class="invertable drawing" src=/images/cellular_automata/sequences.png alt="Arrangement of $n=1,2,3$ states and the possible neighbor sequences for each. The grey boxes show that for each additional state, we include the previous sequences."></p>
<p>Now that we can compute the maximum index of any sequence given its length $n$, and target sum $s$, we can finally compute an index. The process is this:</p>
<p>$$
\text{for } i=0 \text{ to } n-1:\
v = v + \binom{s + n - i - 1}{s} - \binom{s - S_i + n - i - 1}{s - S_i} , s = s - S_i
$$</p>
<p>&mldr;where $v$, which is initialized to 0, is the computed index of the given sequence $S$. $s$ is the remaining sum of the elements in the sequence after $i$, which begins as our target sum (for our purposes, 8). $s$ decreases by the value of each element of $S$ as we iterate through it.</p>
<p>$\binom{s + n - i - 1}{s}$ is the formula for computing max index, except we are computing the max index for the sequences of length $n-i$ which sum to the remaining sum of the whole sequence, $s$.</p>
<p>$\binom{s - S_i + n - i - 1}{s - S_i}$ provides the max index of the sequences of length $n-i$ which sum to $s-S_i$, which is just the remaining sum after the element $S_i$.</p>
<p>Taking the difference of these two quantities gives us the index of the sequence up to $i$. By summing all $i &lt; n-1$, we get the index of the whole sequence!</p>
<p>For clarity, I&rsquo;ve also written the algorithm in Python:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#09f;font-style:italic># n: sequence length</span>
<span style=color:#09f;font-style:italic># S: the sequence</span>
<span style=color:#09f;font-style:italic># s: the integer value which each sequence sums to</span>

<span style=color:#09f;font-style:italic># The computed index, starts at 0</span>
v <span style=color:#555>=</span> <span style=color:#f60>0</span>

<span style=color:#09f;font-style:italic># algorithm: Consider each element of the sequence S as a subsequence,</span>
<span style=color:#09f;font-style:italic>#  where each element is an increasingly smaller subsequence.</span>
<span style=color:#09f;font-style:italic>#  By summing together the indices of each subsequence, we get the</span>
<span style=color:#09f;font-style:italic>#  index of the whole sequence. We start with the longest subsequence.</span>
<span style=color:#069;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#366>range</span>(n <span style=color:#555>-</span> <span style=color:#f60>1</span>):
    <span style=color:#09f;font-style:italic># l: Max index of subsequence that sums to n minus whatever we&#39;ve seen so far</span>
    l <span style=color:#555>=</span> comb((s) <span style=color:#555>+</span> (n <span style=color:#555>-</span> i <span style=color:#555>-</span> <span style=color:#f60>1</span>), s) 
    <span style=color:#09f;font-style:italic># r: Like l, but for sequences that sum to current minus S[i], the element we are considering</span>
    r <span style=color:#555>=</span> comb((s <span style=color:#555>-</span> S[i]) <span style=color:#555>+</span> (n <span style=color:#555>-</span> i <span style=color:#555>-</span> <span style=color:#f60>1</span>), s <span style=color:#555>-</span> S[i])
    <span style=color:#09f;font-style:italic># Add l-r, the index of the part of the sequence we&#39;ve seen so far</span>
    v <span style=color:#555>+=</span> ( l <span style=color:#555>-</span> r )
    <span style=color:#09f;font-style:italic># Subtract the current sequence element from current sum</span>
    s <span style=color:#555>-=</span> S[i]
</code></pre></div><p><img src=/images/cellular_automata/banner3.gif alt="complex gliders"></p>
<h2 id=implementation>Implementation<a class=anchor href=#implementation>#</a></h2>
<p>To implement this algorithm efficiently in a shader, we need to pre-compute binomial coefficients into a texture:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#069;font-weight:700>function</span> buildBinomial() {
    <span style=color:#069;font-weight:700>const</span> data <span style=color:#555>=</span> <span style=color:#069;font-weight:700>new</span> Uint32Array(<span style=color:#f60>32</span> <span style=color:#555>*</span> <span style=color:#f60>32</span>);
    data.fill(<span style=color:#f60>0</span>);
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>let</span> n <span style=color:#555>=</span> <span style=color:#f60>0</span>; n <span style=color:#555>&lt;</span> <span style=color:#f60>32</span>; n<span style=color:#555>++</span>) {
        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>let</span> k <span style=color:#555>=</span> <span style=color:#f60>0</span>; k <span style=color:#555>&lt;</span> <span style=color:#f60>32</span>; k<span style=color:#555>++</span>) {
            data[k <span style=color:#555>*</span> <span style=color:#f60>32</span> <span style=color:#555>+</span> n] <span style=color:#555>=</span> binomial(n, k);
        }
    }
    <span style=color:#069;font-weight:700>const</span> binomialTex <span style=color:#555>=</span> <span style=color:#069;font-weight:700>this</span>.gl.createTexture();
    <span style=color:#069;font-weight:700>this</span>.gl.bindTexture(<span style=color:#069;font-weight:700>this</span>.gl.TEXTURE_2D, binomialTex);
    <span style=color:#09f;font-style:italic>// We use 32-bit unsigned integers because we need to store large numbers
</span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>this</span>.gl.texImage2D(<span style=color:#069;font-weight:700>this</span>.gl.TEXTURE_2D, <span style=color:#f60>0</span>, <span style=color:#069;font-weight:700>this</span>.gl.R32UI, <span style=color:#f60>32</span>, <span style=color:#f60>32</span>, <span style=color:#f60>0</span>, <span style=color:#069;font-weight:700>this</span>.gl.RED_INTEGER, <span style=color:#069;font-weight:700>this</span>.gl.UNSIGNED_INT, data);
}
</code></pre></div><p>We access the texture like this, using texelFetch():</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GLSL data-lang=GLSL><span style=color:#099>#version 300 es</span>

<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uBinomial

<span style=color:#09f;font-style:italic>// Returns binomial coefficient (n choose k) from precompute texture</span>
<span style=color:#069;font-weight:700>int</span> binomial(<span style=color:#069;font-weight:700>int</span> n, <span style=color:#069;font-weight:700>int</span> k) {
    <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>int</span>(texelFetch(uBinomial, <span style=color:#069;font-weight:700>ivec2</span>(n, k), <span style=color:#f60>0</span>).r);
}
</code></pre></div><p>Finally, we have everything we need for the final shader!</p>
<div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#09f;font-style:italic>// simulate.frag</span>
<span style=color:#099>#version 300 es</span>
<span style=color:#069;font-weight:700>precision</span> <span style=color:#069;font-weight:700>mediump</span> <span style=color:#069;font-weight:700>float</span>;

<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uSim;   <span style=color:#09f;font-style:italic>// Input states texture</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uRule;      <span style=color:#09f;font-style:italic>// The cellular automata rule</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>highp</span> usampler2D uBinomial;  <span style=color:#09f;font-style:italic>// Precomputed binomial coefficents</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>vec2</span> uSize;                  <span style=color:#09f;font-style:italic>// Size of simulation canvas in pixels</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>int</span> uStates;                 <span style=color:#09f;font-style:italic>// Number of states in this rule (MAX 14)</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>int</span> uSubIndices;             <span style=color:#09f;font-style:italic>// Number pf subrule indices</span>

<span style=color:#069;font-weight:700>in</span> <span style=color:#069;font-weight:700>vec2</span> vTextureCoord;

<span style=color:#069;font-weight:700>out</span> uvec3 fragColor;

<span style=color:#09f;font-style:italic>// Returns binomial coefficient (n choose k) from precompute texture</span>
<span style=color:#069;font-weight:700>int</span> binomial(<span style=color:#069;font-weight:700>int</span> n, <span style=color:#069;font-weight:700>int</span> k) {
    <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>int</span>(texelFetch(uBinomial, <span style=color:#069;font-weight:700>ivec2</span>(n, k), <span style=color:#f60>0</span>).r);
}

<span style=color:#069;font-weight:700>void</span> main(<span style=color:#069;font-weight:700>void</span>) {
    <span style=color:#069;font-weight:700>int</span> curstate <span style=color:#555>=</span> <span style=color:#069;font-weight:700>int</span>(texture(uSim, vTextureCoord).r);

    <span style=color:#09f;font-style:italic>// Neighbor counts by state index</span>
    <span style=color:#069;font-weight:700>int</span> N[<span style=color:#f60>14</span>] <span style=color:#555>=</span> <span style=color:#069;font-weight:700>int</span>[](<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>);
    N[curstate] <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;

    <span style=color:#09f;font-style:italic>// Determine neighbor counts</span>
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> x <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; x <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; x <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> y <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; y <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; y <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
            uint i <span style=color:#555>=</span> texture(uSim, vTextureCoord <span style=color:#555>+</span> (<span style=color:#069;font-weight:700>vec2</span>(x, y) <span style=color:#555>/</span> uSize)).r;
            N[i] <span style=color:#555>+=</span> <span style=color:#f60>1</span>;
        }
    }

    <span style=color:#09f;font-style:italic>// Determine the index of the integer sequence formed by the neighbor counts</span>
    <span style=color:#069;font-weight:700>int</span> seqIndex <span style=color:#555>=</span> <span style=color:#f60>0</span>;
    <span style=color:#069;font-weight:700>int</span> s <span style=color:#555>=</span> <span style=color:#f60>8</span>;
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> i <span style=color:#555>=</span> <span style=color:#f60>0</span>; i <span style=color:#555>&lt;</span> <span style=color:#f60>13</span>; i<span style=color:#555>++</span>) {
        <span style=color:#069;font-weight:700>if</span> (N[i] <span style=color:#555>&gt;</span> <span style=color:#f60>0</span>) {
            <span style=color:#069;font-weight:700>int</span> x <span style=color:#555>=</span> uStates <span style=color:#555>-</span> i <span style=color:#555>-</span> <span style=color:#f60>1</span>;
            seqIndex <span style=color:#555>+=</span> binomial(s <span style=color:#555>+</span> x, s) <span style=color:#555>-</span> binomial(s <span style=color:#555>-</span> N[i] <span style=color:#555>+</span> x, s <span style=color:#555>-</span> N[i]);
            s <span style=color:#555>-=</span> N[i];
        }
    }
    <span style=color:#09f;font-style:italic>// Compute final index into rule tex given current state and neighbor states</span>
    <span style=color:#069;font-weight:700>int</span> ruleIndex <span style=color:#555>=</span> curstate <span style=color:#555>*</span> uSubIndices <span style=color:#555>+</span> seqIndex;
    <span style=color:#09f;font-style:italic>// Convert 1D rule index into 2D coordinate into rule texture</span>
    uint newstate <span style=color:#555>=</span> texelFetch(uRule, <span style=color:#069;font-weight:700>ivec2</span>(ruleIndex <span style=color:#555>%</span> <span style=color:#f60>1024</span>, ruleIndex <span style=color:#555>/</span> <span style=color:#f60>1024</span>), <span style=color:#f60>0</span>).r;

    fragColor <span style=color:#555>=</span> uvec3(newstate);
}
</code></pre></div><p>Now we have a working shader that simulates arbitrary multi-state cellular automatons! You can see a live demo <a href=https://benpm.github.io/cellarium/ target=_blank rel="noreferrer noopener">here</a>, and all the source code <a href=https://github.com/benpm/cellarium target=_blank rel="noreferrer noopener">here</a>.</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/x-mathjax-config>
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>
</article>
<ul class=tags__list>
<li class=tag__item>
<a class=tag__link href=https://benpm.github.io/tags/webgl/>webgl</a>
</li>
<li class=tag__item>
<a class=tag__link href=https://benpm.github.io/tags/cellular-automata/>cellular-automata</a>
</li></ul>
<div class=pagination>
<a class=pagination__item href=https://benpm.github.io/blog/how-to-invert/reverse/transform-a-map-at-compile-time-in-c++/>
<span class=pagination__label>Previous Post</span>
<span class=pagination__title>C++ Invert Map at Compile Time</span>
</a>
</div>
<footer class=post__footer>
<div class=social-icons>
<a class=social-icons__link title=Twitter href=https://twitter.com/_bpmw target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/twitter.svg)></div>
</a>
<a class=social-icons__link title=GitHub href=https://github.com/benpm target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/github.svg)></div>
</a>
<a class=social-icons__link title=YouTube href=https://www.youtube.com/c/BenjaminMastripolito target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/youtube.svg)></div>
</a>
<a class=social-icons__link title=SoundCloud href=https://soundcloud.com/trope target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/soundcloud.svg)></div>
</a>
<a class=social-icons__link title=ItchIO href=https://ben-m.itch.io/ target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/itchio.svg)></div>
</a>
<a class=social-icons__link title=ko-fi href=https://ko-fi.com/benpm target=_blank rel=noopener>
<div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/ko-fi.svg)></div>
</a>
</div>
<p></p>
</footer>
</div>
</div>
</div>
</main>
<script src=/js/index.min.575dda8d49ee02639942c63564273e6da972ab531dda26a08800bdcb477cbd7f.js integrity="sha256-V13ajUnuAmOZQsY1ZCc+balyq1Md2iagiAC9y0d8vX8=" crossorigin=anonymous></script>
<script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script>
<script src=/js/theme_toggle.min.a3c1e4cedf14141c9ccc933fb773465f6e7061318f29bfcd7ef11673f86943a7.js integrity="sha256-o8Hkzt8UFByczJM/t3NGX25wYTGPKb/NfvEWc/hpQ6c=" crossorigin=anonymous></script>
<div id=theme-toggle-button class=invertable onclick=toggleTheme()>
</div>
</body>
</html>