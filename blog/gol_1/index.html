<!doctype html><html lang=en-us><head><title>Cellular Automata in WebGL: Part 1 | benpm.github.io</title><meta charset=utf-8><meta name=language content="en"><meta name=description content="Simulating Conway's Game of Life and other totalistic cellular automata in a webgl fragment shader, with dynamic rules"><meta name=keywords content="game of life ,cellular automata ,webgl ,glsl ,shader ,fragment ,simulation"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cellular Automata in WebGL: Part 1"><meta name=twitter:description content="Simulating Conway&amp;#39;s Game of Life and other totalistic cellular automata in a webgl fragment shader, with dynamic rules"><meta name=twitter:site content="https://twitter.com/_bpmw"><meta name=twitter:creator content="https://twitter.com/_bpmw"><link rel="shortcut icon" type=image/png href=/favicon.ico><link type=text/css rel=stylesheet href=/css/post.min.2cb93c91050d1853bf971cc31e00122edd6e0f405aa1de3b7f8ef67ea3b5a79a.css integrity="sha256-LLk8kQUNGFO/lxzDHgASLt1uD0Baod47f472fqO1p5o="><link type=text/css rel=stylesheet href=/css/custom.min.2dc9a0d1be1d62a1b439d9701311d23a71df86b1ceb7a87b6e4becf87595cd2b.css integrity="sha256-Lcmg0b4dYqG0OdlwExHSOnHfhrHOt6h7bkvs+HWVzSs="><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/benpm.github.io\/"},"articleSection":"blog","name":"Cellular Automata in WebGL: Part 1","headline":"Cellular Automata in WebGL: Part 1","description":"Simulating Conway\u0027s Game of Life and other totalistic cellular automata in a webgl fragment shader, with dynamic rules","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2020","datePublished":"2020-07-28 10:08:45 -0600 -0600","dateModified":"2020-07-28 10:08:45 -0600 -0600","url":"https:\/\/benpm.github.io\/blog\/gol_1\/","wordCount":"1259","keywords":["game of life","cellular automata","webgl","glsl","shader","fragment","simulation","Blog"]}</script></head><body><div class=burger__container><div class=burger aria-controls=navigation aria-label=Menu><div class="burger__meat burger__meat--1"></div><div class="burger__meat burger__meat--2"></div><div class="burger__meat burger__meat--3"></div></div></div><nav class=nav id=navigation><ul class=nav__list><li><a href=/>_splash</a><div class=indicator></div></li><li><a class=active href=/blog>blog</a><div class="indicator active"></div></li><li><a href=/experiments>experiments</a><div class=indicator></div></li><li><a href=/gamedev>gamedev</a><div class=indicator></div></li><li><a href=/music>music</a><div class=indicator></div></li><li><a href=/projects>projects</a><div class=indicator></div></li></ul></nav><main><div class=flex-wrapper><div class=post__container><div class=post><header class=post__header><h1 id=post__title>Cellular Automata in WebGL: Part 1</h1><time datetime="2020-07-28 10:08:45 -0600 -0600" class=post__date>Jul 28 2020</time></header><article class=post__content><p>I&rsquo;ve always been fascinated with cellular automata, like Conway&rsquo;s Game of Life:</p><p><img src=/images/cellular_automata/gol_1.gif alt="game of life"></p><p>The idea that simple rules can produce structured, complex systems is beautiful to me. Of course I&rsquo;m not the only one, <a href="https://www.youtube.com/watch?v=VguG_y05Xe8">Stephen Wolfram really has a thing for em&rsquo;</a>.</p><p><img src=/images/cellular_automata/machine_rule.gif alt="machine-like rule"></p><p>Anyways, I wanted a fun way to create and tweak cellular automata rules, so I decided to write a <a href=https://benpm.github.io/webgl-cellular-automata/>generalized cellular automaton simulator in WebGL</a>. This post is about how it is implemented and what new interesting possibilities await!</p><iframe src=https://itch.io/embed/715896 width=552 height=167 frameborder=0><a href=https://ben-m.itch.io/webcell>WebGL Cellular Automata Explorer by Benjamin Mastripolito</a></iframe><h2 id=how-it-works>How it Works<a class=anchor href=#how-it-works>#</a></h2><p>Basically, cellular automata consist of, well, cells, each with exactly the same set of possible states. To determine their states, they use a rule. These rules are basically functions that take the states of a cell&rsquo;s neighbors, and possibly the cell itself (like in game of life), as input, and produce the cell&rsquo;s new state as output. Through iteration over discrete time, the whole space evolves:</p><p><img src=/images/cellular_automata/worms_rule.gif alt="worms rule"></p><p>Now, that&rsquo;s a very general definition. For the sake of this particular demonstration we will only take into account a subset of all possible cellular automata, called <em>totalistic</em> cellular automata. &ldquo;Totalistic&rdquo; because its rules only take into account the <em>total</em> number of cells in the neighborhood, ignoring their arrangement.</p><p><img src=/images/cellular_automata/illustration_1.png alt="totalistic ca"></p><p>So what is inside the neighborhood? Well we&rsquo;ll focus on the <em>Moore Neighborhood</em>, which consists of the eight surrounding cells:</p><p><img src=/images/cellular_automata/illustration_2.png alt="moore neighborhood"></p><p>And for now we only have two possible states: on and off. This may seem like a somewhat restrictive subset, but keep in mind that it contains Conway&rsquo;s Game of Life, as well as quite a large number of other rules. How many other rules, you ask? Well get out your pocket calculator, we&rsquo;re going to do some simple math.</p><p>First, we need to think about how to represent a rule in our subset as a string of bits. This will be relevant later when we look at the simulator&rsquo;s code. So what information do we actually need? Well we need to know what to do with each possible input. Our inputs will be the number of neighbors (because it is totalistic) and the current state of the cell.</p><p>There are ($ s = 2 $) possible states, and ($ N = 9 $) possible values for the number of neighbors (that&rsquo;s 0, 1, 2&mldr; up to and including 8). If we combine these, we get 9 bits for all the neighbor states, twice, for each possible existing state. That means we need exactly 18 bits to fully specify a rule in our set. So it follows that the number of possible rules is:</p><p>$$ n = 2^{sN} = 2^{18} = 262144 $$</p><p>Not bad! Most of those are probably not very interesting, but that&rsquo;s okay. It&rsquo;s still a pretty large space to explore.</p><p><img src=/images/cellular_automata/spread_rule.gif alt="spread rule"></p><p>So know we have a pretty good idea of how to represent any rule in our set in a useful way, just a string of 18 bits! Let&rsquo;s take a look at Game of Life in this format. The rules of Game of Life, in English, are:</p><ol><li>Any <em>on</em> cell with two or three <em>on</em> neighbours stays <em>on</em></li><li>Any <em>off</em> cell with three <em>on</em> neighbours turns <em>on</em></li><li>All other cells turn <em>off</em>, including cells that are already <em>off</em></li></ol><p>So let&rsquo;s look at the representation in our bit string:</p><p><img src=/images/cellular_automata/illustration_3.png alt="bit representation"></p><p>Nice! That&rsquo;s really easy to pass to a shader. We&rsquo;ll just write that information to a texture and make a uniform to access it:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>sampler2D</span> uRule;

<span style=color:#069;font-weight:700>void</span> main(<span style=color:#069;font-weight:700>void</span>) {
    ...
    <span style=color:#069;font-weight:700>int</span> state <span style=color:#555>=</span> texture2D(uRule, <span style=color:#069;font-weight:700>vec2</span>(total, previousState));
    ...
}
</code></pre></div><p>Yeah&mldr; if you&rsquo;ve written GLSL you know there&rsquo;s a bunch of stuff wrong here, but I&rsquo;m just simplifying so it isn&rsquo;t confusing. Okay, now we can use the rule, so all we need to do now is count the total number of neighbors. A simple way to do that is with a loop:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#09f;font-style:italic>// The coordinates of the current pixel</span>
<span style=color:#069;font-weight:700>varying</span> <span style=color:#069;font-weight:700>vec2</span> vTextureCoord;
<span style=color:#09f;font-style:italic>// Sampler into the texture</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>sampler2D</span> uSampler;
<span style=color:#09f;font-style:italic>// Size of the texture</span>
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>float</span> uWidth;
<span style=color:#069;font-weight:700>uniform</span> <span style=color:#069;font-weight:700>float</span> uHeight;

<span style=color:#069;font-weight:700>void</span> main(<span style=color:#069;font-weight:700>void</span>) {
    <span style=color:#09f;font-style:italic>// Size of a pixel</span>
    <span style=color:#069;font-weight:700>vec2</span> pSize <span style=color:#555>=</span> <span style=color:#069;font-weight:700>vec2</span>(<span style=color:#f60>1.0</span> <span style=color:#555>/</span> uWidth, <span style=color:#f60>1.0</span> <span style=color:#555>/</span> uHeight);
    <span style=color:#069;font-weight:700>int</span> previousState <span style=color:#555>=</span> texture2D(uSampler, vTextureCoord);
    <span style=color:#09f;font-style:italic>// Count neighbors</span>
    <span style=color:#069;font-weight:700>int</span> total <span style=color:#555>=</span> <span style=color:#f60>0</span>;
    <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> x <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; x <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; x <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>int</span> y <span style=color:#555>=</span> <span style=color:#555>-</span><span style=color:#f60>1</span>; y <span style=color:#555>&lt;=</span> <span style=color:#f60>1</span>; y <span style=color:#555>+=</span> <span style=color:#f60>1</span>) {
            total <span style=color:#555>+=</span> texture2D(uSampler, vTextureCoord <span style=color:#555>+</span> pSize <span style=color:#555>*</span> <span style=color:#069;font-weight:700>vec2</span>(x, y));
        }
    }
    <span style=color:#069;font-weight:700>int</span> state <span style=color:#555>=</span> texture2D(uRule, <span style=color:#069;font-weight:700>vec2</span>(total, previousState));
}
</code></pre></div><p>But wait!! That total will include the value of the current pixel, which we don&rsquo;t want! Let&rsquo;s remove it. Instead of <code>int total = 0;</code>, we&rsquo;ll write <code>int total = -previousState</code>.</p><p>By removing the value of the current cell in this way, we avoid branching, which can be expensive for the GPU, <a href=https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-34-gpu-flow-control-idioms>depending on the situation</a>. In our case, we can avoid it while keeping the code simple, which is great.</p><p>The last notable element to getting this to work is the double framebuffer. In order to simulate steps in time, we need to apply this shader to its own result. The only way to do that is to have two different textures and alternate each between being the source and the destination. This happens every time step, however long we choose that to be.</p><p>That about does it! You can look at the code for the simulation <a href=https://github.com/benpm/webgl-cellular-automata>here</a>.</p><h2 id=finding-interesting-rules>Finding Interesting Rules<a class=anchor href=#finding-interesting-rules>#</a></h2><p>Now that we have a nice framework for running the simulation, we can start finding interesting rules. The naive way to do this is to just create random rule strings. This can create interesting results, but usually it just produces boring noise-like rules:</p><p><img src=/images/cellular_automata/noise.png alt="noise rule"></p><p>How about just modifying game of life? Well what we can do is just flip a single bit of a rule&rsquo;s bitstring. Unfortunately, since Game of Life is very unusual rule in our set, adjacent rules aren&rsquo;t actually very interesting.</p><p>Instead, let&rsquo;s start with a cool maze generator rule I found randomly (there are a lot of rules like this):</p><p><img src=/images/cellular_automata/maze.png alt="maze rule"></p><p>Flip a single bit, and we get:</p><p><img src=/images/cellular_automata/sierpinski_arrowheads.png alt="sierpinski arrowheads"></p><p>Sierpinski arrowheads! Very different and interesting, and only a single bit away. Let&rsquo;s do it again:</p><p><img src=/images/cellular_automata/growth.png alt="interesting growing maze"></p><p>By iterating existing rules in this way, we can often produce fun new rules. I have already found almost a dozen rules by this process, which I have included as presets in the simulator. <a href=https://benpm.github.io/webgl-cellular-automata/>Check it out</a> and try and find some yourself!</p><h2 id=next-steps>Next Steps<a class=anchor href=#next-steps>#</a></h2><p>Well now we have a functioning cellular automata simular running in the browser. It&rsquo;s extremely fast because it runs on the GPU, as well as very dynamic, as arbitrary rules can be passed as textures to the fragment shader.</p><p>Next, we&rsquo;ll look at expanding our set of possible rules by allowing <strong>more than two possible states</strong>. It will be a little complicated, as the way we specify rules will have to change. Not only will there be multiple possible input states (remember our rule is really a function), but also multiple quantities of neighbors. If we have 4 neighbors of state A, we can only have a maximum total of 4 for other states B, C, D, etc. If we want our rule texture to occupy the least possible space, we need to think carefuly about representation.</p><p>This will allow us to simulate some really interesting rules like <a href=https://www.wikiwand.com/en/Brian%27s_Brain>Brian&rsquo;s Brain</a> (3 states), <a href=https://www.wikiwand.com/en/Wireworld>Wireworld</a> (4 states), <a href=https://www.wikiwand.com/en/Codd%27s_cellular_automaton>Codd&rsquo;s CA</a> (8 states), and any other totalistic rule we can think of! At some point, we&rsquo;ll also take a look at non-totalistic rules, which will allow an absolutely astounding rule space (more possible rules than particles in the universe!)</p><p>Stay tuned!</p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script></article><ul class=tags__list><li class=tag__item><a class=tag__link href=https://benpm.github.io/tags/webgl/>webgl</a></li><li class=tag__item><a class=tag__link href=https://benpm.github.io/tags/cellular-automata/>cellular-automata</a></li></ul><div class=pagination><a class=pagination__item href=https://benpm.github.io/blog/2d-top-down-collisions-with-rectangles-aabbs/><span class=pagination__label>Previous Post</span>
<span class=pagination__title>Rectangle (AABB) Collisions</span></a></div><footer class=post__footer><div class=social-icons><a class=social-icons__link title=Twitter href=https://twitter.com/_bpmw target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/twitter.svg)></div></a><a class=social-icons__link title=GitHub href=https://github.com/benpm target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/github.svg)></div></a><a class=social-icons__link title=YouTube href=https://www.youtube.com/c/BenjaminMastripolito target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/youtube.svg)></div></a><a class=social-icons__link title=SoundCloud href=https://soundcloud.com/trope target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/soundcloud.svg)></div></a><a class=social-icons__link title=ItchIO href=https://ben-m.itch.io/ target=_blank rel=noopener><div class=social-icons__icon style=background-image:url(https://benpm.github.io/svg/itchio.svg)></div></a></div><p></p></footer></div></div></div></main><script src=/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr+kQ=" crossorigin=anonymous></script><script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script><script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script></body></html>